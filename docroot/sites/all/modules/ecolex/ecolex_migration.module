<?php


/**
 * Implements hook_migrate_api().
 *
 * Set the API level to 2, for migration classes to be recognized by Migrate.
 */
function ecolex_migration_migrate_api() {
  $ret = array(
    'api' => 2,
    'groups' => array(
      'ecolex' => array(
        'title' => 'ECOLEX content migration'
      )
    ),
    'migrations' => array()
  );
  if($base_data_dir = variable_get('ecolex_data_dir')) {
    $ret['migrations']['EcolexTreaties'] = array(
      'class_name' => 'EcolexTreatyMigrateWiki',
      'data_dir' => $base_data_dir . '/treaties/',
      'group_name' => 'ecolex',
    );
    $ret['migrations']['EcolexLegislation'] = array(
      'class_name' => 'EcolexLegislationMigrate',
      'data_dir' => $base_data_dir . '/documents/',
      'group_name' => 'ecolex',
    );
    $ret['migrations']['EcolexLiterature'] = array(
      'class_name' => 'EcolexLiteratureMigrate',
      'data_dir' => $base_data_dir . '/literature/',
      'group_name' => 'ecolex',
    );
    $ret['migrations']['EcolexCourtDecisions'] = array(
      'class_name' => 'EcolexCourtDecisionsMigrate',
      'data_dir' => $base_data_dir . '/courtdecisions/',
      'group_name' => 'ecolex',
    );
  }
  return $ret;
}

abstract class EcolexMigrateSource extends MigrateSource {

  /**
   * Return the number of available source records.
   */
  public function computeCount() {
    $files = file_scan_directory($this->data_dir, '/.*/');
    $ret = 0;
    foreach ($files as $i => $file) {
      try {
        $docs = @simplexml_load_file($file->uri);
        if (!$docs) {
          continue;
        }
        foreach ($docs as $doc) {
          $ret++;
        }
      }
      catch (Exception $e) {
        // Swallow
      }
    }
    return $ret;
  }

  /**
   * Do whatever needs to be done to start a fresh traversal of the source data.
   *
   * This is always called at the start of an import, so tasks such as opening
   * file handles, running queries, and so on should be performed here.
   */
  public function performRewind() {
    reset($this->data);
  }

  /**
   * Fetch the next row of data, returning it as an object.
   *
   * @return object
   *   FALSE data as stdClass, FALSE when there is no more data available.
   */
  public function getNextRow() {
    if (empty($this->data)) {
      $this->readData();
    }
    $item = NULL;
    if (count($this->data)) {
      $item = current($this->data);
      next($this->data);
    }
    return $item;
  }

  /**
   * Add messages during data retrieval for debugging.
   *
   * @param string $msg
   *   Message string
   * @param int $severity
   *   Migration message level
   */
  protected function setMessage($msg,
    $severity = MigrationBase::MESSAGE_WARNING) {
    if (function_exists('drush_log')) {
      drush_log($msg, 'warning');
    }
    drupal_set_message($msg);
    $this->activeMigration->queueMessage($msg, $severity);
  }


  protected function languageCode($languageName) {
    require_once DRUPAL_ROOT . '/includes/iso.inc';
    $languages = _locale_get_predefined_list();
    if ($languageName == 'Portuguese') {
      $languageName = 'Portuguese, International';
    }
    $languageName = strtolower($languageName);
    foreach($languages as $code => $names) {
      if (in_array($languageName, array_map('strtolower',$names))) {
        return $code;
      }
    }
    return $languageName;
  }
}